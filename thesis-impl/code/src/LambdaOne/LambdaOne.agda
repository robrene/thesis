module LambdaOne.LambdaOne where

open import Data.List using (List; []; _âˆ·_)
open import Data.PolyTypes

open import LambdaOne.Environment

data Gate : Set where
  TRUE FALSE NOT AND OR : Gate

open Gate public

inputs : Gate â†’ List Uâ‚š
inputs TRUE   = []
inputs FALSE  = []
inputs NOT    = ğŸš âˆ· []
inputs AND    = ğŸš âˆ· ğŸš âˆ· []
inputs OR     = ğŸš âˆ· ğŸš âˆ· []

output : Gate â†’ Uâ‚š
output TRUE   = ğŸš
output FALSE  = ğŸš
output NOT    = ğŸš
output AND    = ğŸš
output OR     = ğŸš

data Î›â‚ : (Î“ : Ctxt) â†’ (Î” : List Uâ‚š) â†’ (Ï„ : Uâ‚š) â†’ Set where
  âŸ¨_âŸ©               : âˆ€ {Î“}          â†’ (g : Gate)                                                            â†’ Î›â‚ Î“ (inputs g) (output g)
  #[_]              : âˆ€ {Î“ Ï„}        â†’ (r : Ref Î“ Ï„)                                                         â†’ Î›â‚ Î“ [] Ï„
  _$â‚_              : âˆ€ {Î“ Î” Î± Î²}    â†’ (f : Î›â‚ Î“ (Î± âˆ· Î”) Î²) â†’ (x : Î›â‚ Î“ [] Î±)                                â†’ Î›â‚ Î“ Î” Î²
  letâ‚“_inâ‚‘_         : âˆ€ {Î“ Î” Î± Ï„}    â†’ (x : Î›â‚ Î“ [] Î±) â†’ (e : Î›â‚ (Î± âˆ· Î“) Î” Ï„)                                â†’ Î›â‚ Î“ Î” Ï„
  _,â‚_              : âˆ€ {Î“ Î± Î²}      â†’ (x : Î›â‚ Î“ [] Î±) â†’ (y : Î›â‚ Î“ [] Î²)                                     â†’ Î›â‚ Î“ [] (Î± âŠ— Î²)
  caseâŠ—_of_         : âˆ€ {Î“ Î” Î± Î² Ï„}  â†’ (xy : Î›â‚ Î“ [] (Î± âŠ— Î²)) â†’ (f : Î›â‚ (Î± âˆ· Î² âˆ· Î“) Î” Ï„)                     â†’ Î›â‚ Î“ Î” Ï„
  inlâ‚              : âˆ€ {Î“ Î± Î²}      â†’ (x : Î›â‚ Î“ [] Î±)                                                       â†’ Î›â‚ Î“ [] (Î± âŠ• Î²)
  inrâ‚              : âˆ€ {Î“ Î± Î²}      â†’ (y : Î›â‚ Î“ [] Î²)                                                       â†’ Î›â‚ Î“ [] (Î± âŠ• Î²)
  caseâŠ•_either_or_  : âˆ€ {Î“ Î” Î± Î² Ï„}  â†’ (xy : Î›â‚ Î“ [] (Î± âŠ• Î²)) â†’ (f : Î›â‚ (Î± âˆ· Î“) Î” Ï„) â†’ (g : Î›â‚ (Î² âˆ· Î“) Î” Ï„)  â†’ Î›â‚ Î“ Î” Ï„

infixl 10 _$â‚_

#â‚€ : âˆ€ {Î“ Ï„â‚€}              â†’ Î›â‚ (Ï„â‚€ âˆ· Î“) [] Ï„â‚€
#â‚€ = #[ top ]
#â‚ : âˆ€ {Î“ Ï„â‚€ Ï„â‚}           â†’ Î›â‚ (Ï„â‚€ âˆ· Ï„â‚ âˆ· Î“) [] Ï„â‚
#â‚ = #[ pop top ]
#â‚‚ : âˆ€ {Î“ Ï„â‚€ Ï„â‚ Ï„â‚‚}        â†’ Î›â‚ (Ï„â‚€ âˆ· Ï„â‚ âˆ· Ï„â‚‚ âˆ· Î“) [] Ï„â‚‚
#â‚‚ = #[ pop (pop top) ]
#â‚ƒ : âˆ€ {Î“ Ï„â‚€ Ï„â‚ Ï„â‚‚ Ï„â‚ƒ}     â†’ Î›â‚ (Ï„â‚€ âˆ· Ï„â‚ âˆ· Ï„â‚‚ âˆ· Ï„â‚ƒ âˆ· Î“) [] Ï„â‚ƒ
#â‚ƒ = #[ pop (pop (pop top)) ]
#â‚„ : âˆ€ {Î“ Ï„â‚€ Ï„â‚ Ï„â‚‚ Ï„â‚ƒ Ï„â‚„}  â†’ Î›â‚ (Ï„â‚€ âˆ· Ï„â‚ âˆ· Ï„â‚‚ âˆ· Ï„â‚ƒ âˆ· Ï„â‚„ âˆ· Î“) [] Ï„â‚„
#â‚„ = #[ pop (pop (pop (pop top))) ]

Î›Î¹ : (Î” : List Uâ‚š) â†’ (Ï„ : Uâ‚š) â†’ Set
Î›Î¹ Î” Ï„ = âˆ€ {Î“} â†’ Î›â‚ Î“ Î” Ï„

âŸ¨TRUEâŸ© : Î›Î¹ [] ğŸš
âŸ¨TRUEâŸ© = âŸ¨ TRUE âŸ©

âŸ¨FALSEâŸ© : Î›Î¹ [] ğŸš
âŸ¨FALSEâŸ© = âŸ¨ FALSE âŸ©

âŸ¨NOTâŸ© : Î›Î¹ (ğŸš âˆ· []) ğŸš
âŸ¨NOTâŸ© = âŸ¨ NOT âŸ©

âŸ¨ANDâŸ© : Î›Î¹ (ğŸš âˆ· ğŸš âˆ· []) ğŸš
âŸ¨ANDâŸ© = âŸ¨ AND âŸ©

âŸ¨ORâŸ© : Î›Î¹ (ğŸš âˆ· ğŸš âˆ· []) ğŸš
âŸ¨ORâŸ© = âŸ¨ OR âŸ©

fn-not : Î›Î¹ [] ğŸš â†’ Î›Î¹ [] ğŸš
fn-not x = âŸ¨NOTâŸ© $â‚ x
syntax fn-not x = âŸ¨notâŸ© x

fn-and : Î›Î¹ [] ğŸš â†’ Î›Î¹ [] ğŸš â†’ Î›Î¹ [] ğŸš
fn-and x y = (âŸ¨ANDâŸ© $â‚ x) $â‚ y
syntax fn-and x y = x âŸ¨andâŸ© y

fn-or : Î›Î¹ [] ğŸš â†’ Î›Î¹ [] ğŸš â†’ Î›Î¹ [] ğŸš
fn-or x y = (âŸ¨ORâŸ© $â‚ x) $â‚ y
syntax fn-or x y = x âŸ¨orâŸ© y

fn-nand : Î›Î¹ [] ğŸš â†’ Î›Î¹ [] ğŸš â†’ Î›Î¹ [] ğŸš
fn-nand x y = âŸ¨notâŸ© (x âŸ¨andâŸ© y)
syntax fn-nand x y = x âŸ¨nandâŸ© y

fn-xor : Î›Î¹ [] ğŸš â†’ Î›Î¹ [] ğŸš â†’ Î›Î¹ [] ğŸš
fn-xor x y = (x âŸ¨orâŸ© y) âŸ¨andâŸ© (âŸ¨notâŸ© (x âŸ¨andâŸ© y))
syntax fn-xor x y = x âŸ¨xorâŸ© y
